package mazegenerator

import (
	"testing"
)

func TestPathFinder(t *testing.T) {
	t.Run("Testing path finder on blocked maze", func(t *testing.T) {
		maze := NewMaze(25, 25)

		startX, startY := maze.GetStartPos()
		endX, endY := 5, 5

		if isPathExists(maze, startX, startY, endX, endY) {
			maze.Print()
			t.Errorf("No path should exist")
		}
	})

	t.Run("Testing path finder on valid maze", func(t *testing.T) {
		for _, grid := range mazes {
			width, height := len(grid[0]), len(grid)
			maze := NewMaze(width, height)
			for i := range grid {
				for j := range grid[i] {
					maze.Set(j, i, grid[i][j])
					if grid[i][j] == 'S' {
						maze.Start = Cell{j, i}
					}
					if grid[i][j] == 'E' {
						maze.End = Cell{j, i}
					}
				}
			}

			startX, startY := maze.GetStartPos()
			endX, endY := maze.GetEndPos()

			if startX == endX && startY == endY {
				t.Errorf("Start and end positions overlap")
			}

			if !isPathExists(maze, startX, startY, endX, endY) {
				maze.Print()
				t.Errorf("No valid path found")
			}
		}
	})

	t.Run("Testing path finder on invalid maze", func(t *testing.T) {
		for _, grid := range invalidMazes {
			width, height := len(grid[0]), len(grid)
			maze := NewMaze(width, height)
			for i := range grid {
				for j := range grid[i] {
					maze.Set(j, i, grid[i][j])
					if grid[i][j] == 'S' {
						maze.Start = Cell{j, i}
					}
					if grid[i][j] == 'E' {
						maze.End = Cell{j, i}
					}
				}
			}

			startX, startY := maze.GetStartPos()
			endX, endY := maze.GetEndPos()

			if isPathExists(maze, startX, startY, endX, endY) {
				maze.Print()
				t.Errorf("No valid path should exist")
			}
		}
	})
}

func TestMazePath(t *testing.T) {
	for i := 0; i < 1000; i++ {
		t.Run("Testing maze", func(t *testing.T) {
			maze := GenerateMaze(25, 15, "prim")

			startX, startY := maze.GetStartPos()
			endX, endY := maze.GetEndPos()

			if startX == endX && startY == endY {
				t.Errorf("Start and end positions overlap")
			}

			if !isPathExists(maze, startX, startY, endX, endY) {
				maze.Print()
				t.Errorf("No valid path found")
			}
		})
	}
}

func isPathExists(maze *Maze, startX, startY, endX, endY int) bool {
	visited := make(map[Cell]bool)
	var dfs func(x, y int) bool

	dfs = func(x, y int) bool {
		if x == endX && y == endY {
			return true
		}

		visited[Cell{x, y}] = true
		maze.Set(x, y, '*')

		for _, dir := range DIRS {
			neighbor := Cell{x + dir.x, y + dir.y}
			// Check boundary
			if !maze.IsInner(neighbor.x, neighbor.y) && !maze.IsBoundary(neighbor.x, neighbor.y) {
				continue
			}
			// Skip visited cells and walls
			if visited[neighbor] || maze.IsWall(neighbor.x, neighbor.y) {
				continue
			}

			if dfs(neighbor.x, neighbor.y) {
				return true
			}

		}
		return false
	}

	return dfs(startX, startY)
}

// Mazes for testing.
var mazes = [][][]rune{
	{
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
		{'#', ' ', ' ', ' ', '#', 'E', ' ', ' ', ' ', '#'},
		{'#', ' ', '#', ' ', ' ', '#', '#', ' ', '#', '#'},
		{'#', ' ', ' ', ' ', '#', ' ', '#', ' ', ' ', '#'},
		{'#', ' ', '#', ' ', ' ', '#', ' ', '#', ' ', '#'},
		{'#', ' ', '#', '#', ' ', ' ', ' ', '#', ' ', '#'},
		{'#', ' ', ' ', ' ', '#', ' ', ' ', '#', ' ', '#'},
		{'#', '#', '#', ' ', '#', ' ', ' ', ' ', ' ', '#'},
		{'#', 'S', ' ', ' ', '#', ' ', '#', ' ', ' ', '#'},
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
	},
	{
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
		{'#', 'E', ' ', ' ', ' ', '#', '#', ' ', '#', '#'},
		{'#', '#', '#', '#', ' ', ' ', '#', '#', '#', '#'},
		{'#', '#', ' ', '#', '#', ' ', ' ', '#', '#', '#'},
		{'#', ' ', ' ', '#', '#', '#', ' ', ' ', ' ', '#'},
		{'#', ' ', '#', ' ', '#', '#', '#', '#', ' ', '#'},
		{'#', ' ', '#', ' ', ' ', '#', '#', '#', ' ', '#'},
		{'#', '#', '#', '#', ' ', '#', ' ', ' ', ' ', '#'},
		{'#', 'S', ' ', ' ', ' ', ' ', ' ', '#', '#', '#'},
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
	},
	{
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
		{'#', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', '#'},
		{'#', ' ', '#', ' ', '#', '#', '#', ' ', '#', '#'},
		{'#', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', '#'},
		{'#', ' ', '#', '#', '#', '#', ' ', '#', 'E', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#'},
		{'#', '#', '#', '#', '#', '#', ' ', '#', '#', '#'},
		{'#', 'S', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#'},
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
	},
	{
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', '#'},
		{'#', '#', '#', '#', '#', ' ', '#', '#', ' ', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#'},
		{'#', ' ', '#', '#', '#', '#', '#', '#', ' ', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', ' ', '#', 'E', '#'},
		{'#', '#', ' ', '#', '#', '#', '#', '#', '#', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'S', '#'},
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
	},
	{
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
		{'#', ' ', ' ', ' ', '#', ' ', '#', ' ', ' ', '#'},
		{'#', '#', '#', ' ', '#', ' ', '#', '#', ' ', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#'},
		{'#', ' ', '#', '#', '#', '#', ' ', '#', 'E', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', ' ', '#', '#', '#'},
		{'#', '#', '#', '#', ' ', '#', '#', '#', 'S', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#'},
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
	},
	{
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
		{'#', 'S', '#', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'E', '#'},
		{'#', ' ', '#', ' ', '#', ' ', '#', ' ', '#', '#', '#', '#', '#', '#', '#', ' ', '#', ' ', '#', '#', '#', '#', '#', '#', '#', '#', '#', ' ', '#'},
		{'#', ' ', '#', ' ', '#', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#'},
		{'#', ' ', '#', '#', '#', ' ', '#', ' ', '#', '#', '#', '#', '#', '#', '#', ' ', '#', ' ', '#', '#', '#', '#', '#', '#', '#', ' ', '#', ' ', '#'},
		{'#', ' ', '#', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#'},
		{'#', ' ', '#', ' ', '#', '#', '#', ' ', '#', '#', '#', '#', '#', '#', '#', ' ', '#', ' ', '#', '#', '#', '#', '#', '#', '#', ' ', '#', ' ', '#'},
		{'#', ' ', '#', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#', ' ', '#'},
		{'#', ' ', '#', '#', '#', '#', '#', ' ', '#', ' ', '#', '#', '#', ' ', '#', ' ', '#', ' ', '#', '#', '#', '#', '#', '#', '#', ' ', '#', ' ', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#', ' ', '#'},
		{'#', '#', '#', '#', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#', '#', '#', '#', '#', '#', '#', '#', '#', ' ', '#', ' ', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#', ' ', '#'},
		{'#', ' ', '#', '#', '#', '#', '#', ' ', '#', ' ', '#', ' ', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', ' ', '#', ' ', '#', ' ', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', '#', ' ', '#'},
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
	},
}

var invalidMazes = [][][]rune{
	{
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
		{'#', ' ', ' ', ' ', '#', 'E', ' ', ' ', ' ', '#'},
		{'#', ' ', '#', ' ', ' ', '#', '#', ' ', '#', '#'},
		{'#', ' ', ' ', ' ', '#', ' ', '#', ' ', ' ', '#'},
		{'#', ' ', '#', ' ', ' ', '#', ' ', '#', ' ', '#'},
		{'#', ' ', '#', '#', ' ', ' ', ' ', '#', ' ', '#'},
		{'#', ' ', ' ', ' ', '#', ' ', ' ', '#', ' ', '#'},
		{'#', '#', '#', ' ', '#', ' ', ' ', ' ', ' ', '#'},
		{'#', 'S', '#', ' ', '#', ' ', '#', ' ', ' ', '#'},
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
	},
	{
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
		{'#', ' ', ' ', ' ', '#', ' ', '#', ' ', ' ', '#'},
		{'#', '#', '#', ' ', '#', ' ', '#', '#', ' ', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#'},
		{'#', ' ', '#', '#', '#', '#', ' ', '#', 'E', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', ' ', '#', '#', '#'},
		{'#', '#', '#', '#', ' ', '#', '#', '#', 'S', '#'},
		{'#', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#'},
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
	},
	{
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
		{'#', ' ', ' ', ' ', '#', 'E', '#', ' ', ' ', '#'},
		{'#', ' ', '#', ' ', ' ', '#', ' ', ' ', '#', '#'},
		{'#', ' ', ' ', ' ', '#', ' ', '#', ' ', ' ', '#'},
		{'#', ' ', '#', ' ', ' ', '#', ' ', '#', ' ', '#'},
		{'#', ' ', '#', '#', ' ', ' ', ' ', '#', ' ', '#'},
		{'#', ' ', ' ', ' ', '#', ' ', ' ', '#', ' ', '#'},
		{'#', '#', '#', ' ', '#', ' ', ' ', ' ', ' ', '#'},
		{'#', 'S', ' ', ' ', '#', ' ', '#', ' ', ' ', '#'},
		{'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
	},
}
